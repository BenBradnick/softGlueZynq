<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>softGlueZynq</TITLE>
	<style type="text/css">
	<!--
	blockquote { font-size:smaller;}
	-->
	</style>

</HEAD>
<BODY LANG="en-US" BGCOLOR="#ffffff" DIR="LTR">

<h1><center>The synApps softGlueZynqZynq module (v0.1)</center></h1>
<hr>
<h1>Table of Contents</h1>
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Installation and deployment">Installation and deployment</a></li>
  <li><a href="#User's Manual">User's Manual</a></li>
  <li><a href="#Additional FPGA components">Additional FPGA components</a></li>
  <li><a href="#Saving and restoring circuits">Saving and restoring circuits</a></li>
  <li><a href="#Example circuits">Example circuits</a></li>
  <li><a href="#Field wiring">Field wiring</a></li>
  <li><a href="#Custom Interrupt Handlers">Custom Interrupt Handlers</a></li>
  <li><a href="#Implementation">Implementation</a></li>
</ul>
<hr>

<a name="Overview"></a>
<h2><center>Overview</center></h2>

The <a href="http://www.aps.anl.gov/bcda/synApps">synApps</a>
softGlueZynqZynq module enables <a href="http://www.aps.anl.gov/epics">EPICS</a> users
and application developers to construct small, simple, digital electronic
circuits, and to connect those circuits to field wiring, all by writing to EPICS
PV's.  Because the circuits and field connections are defined entirely by EPICS
PV's, they can be <a
href="http://www.aps.anl.gov/bcda/synApps/autosave/autosave.html">autosave</a>d
and restored, saved as text files (for example, as <a
href="https://htmlpreview.github.io/?https://github.com/epics-modules/autosave/blob/R5-7-1/documentation/autoSaveRestore.html#configMenu">configMenu</a> 
files), emailed from one user to another, etc.  softGlueZynq also provides safe (throttled) user
control over how hardware interrupts are generated by field I/O signals, and how
they are dispatched to cause EPICS processing.  (Interrupts are not supported yet.)

<blockquote> The name <em>softGlue</em> was intended to suggest <em>glue electronics</em> implemented
by <em>soft</em>ware, where <em>glue electronics</em> means those little bits of digital circuitry needed to
connect two or more larger pieces of digital electronics into a working whole.  <em>softGlueZynq</em>
is a rendition of softGlue for the Xilinx Zynq device , which is the combination of an FPGA and
a processor running Linux.</blockquote>

<P>softGlueZynq does this by loading the Zynq FPGA with a predefined collection of circuit
elements (logic gates, counters, flip-flops, etc.), whose inputs and outputs are connected to
switches controlled by EPICS PV's.  softGlueZynq provides a user interface for controlling those
switches, allowing inputs and outputs to be marked with user-specified names, and connecting or
driving inputs and outputs according to those names.

<P>Here's the underlying idea, schematically:
<P><center><img src="softGlueSchematically.jpg" name="softGlueZynq, schematically"></center>


<h3>Requirements</h3>

<P>To use softGlueZynq, you must have the following hardware and software:

<ul>
<li><h4>Hardware</h4>
<ul>

<li>A  <a href="http://zedboard.org/product/microzed">MicroZed</a> (7010 or 7020)

</ul>

<blockquote> softGlueZynq is intended to be useable with any Zynq device, and will certainly be
ported to the MicroZed 7020, and to one or more versions of the PicoZed, but the databases and
MEDM displays supplied in this version are for the MicroZed 7010.  Other devices have not yet been
tested.</blockquote>

<li><h4>Software</h4>
<ul>

<li>The EPICS <a href="http://www.aps.anl.gov/epics/modules/soft/asyn">asyn</a> module, version
	4.6 or higher.

<li>The EPICS extension, <a href="http://www.aps.anl.gov/epics/extensions/msi/index.php">msi</a>,
    version 1-5 or higher.
	
	<blockquote>This tool is needed to build some softGlueZynq databases.</blockquote>

<li>MEDM, or CSS-BOY, or caQtDM, or the ability to adapt some other display
	manager or Channel Access client to implement softGlueZynq's user interface.

</ul>
</ul>

	<blockquote>
	Some of the softGlueZynq databases, displays, and examples presume the availability of
	synApps modules such as calc, busy, and std, but these are not needed
	for any essential feature of softGlueZynq.

	</blockquote>

<p>You do <b>not</b> need to be able to program the Zynq FPGA.  In the default implementation,
the FPGA content is programmed automatically into the module at IOC-boot time.  A Xilinx
.bin file is included with softGlueZynq for this purpose.  softGlueZynq loads the FPGA on every
IOC boot, though it's also possible to reboot the IOC without affecting a running FPGA.


<blockquote>

If you have a copy of the Xilix Vivado software, you can load your own custom FPGA content into
the module, and use softGlueZynq to talk to it.  softGlueZynq was designed with this use in mind,
though we don't yet have documentation on how it's done.

</blockquote>

<h3>Capabilities</h3>

<P>Here are a few examples of the sorts of things that can be accomplished with
softGlueZynq and EPICS: 

<ul>

<li>With no programming at all, softGlueZynq functions simply as a 16-bit digital I/O module.

<li>Conditionally send a trigger signal to a detector after every N steps of a stepper motor.

<li>Conditionally send a trigger signal to a detector after every N(i) steps of
a stepper motor, where N(i) is an array of step-interval numbers.  (This requires
interrupt support, which hasn't been written, or a custom FPGA component, which also
hasn't been written.)

<li>Gate a detector off during the acceleration and deceleration portions of a
steppermotor's motion.

<li>Send a trigger to a detector precisely 23 ms after sending a trigger to a shutter.

<li>Conditionally trigger the execution of an EPICS record on the change of state
of an external signal.  (Requires interrupt support which has not yet been written.)

<li>Implement an extraordinarily smart trigger signal for an oscilloscope.

<li>Implement efficiently a timer useable by EPICS software, with a time resolution that is
much better than the system clock's resolution.  (With this, you can for example cause an
EPICS database to wait for 0.7 ms.)   (Requires interrupt support which has not yet been written.)

</ul>


<h4>Implemented circuit elements</h4>

In this version of softGlueZynq, the FPGA is programmed with the following circuit
elements:

<ul>
<li>Four AND gates
<li>Four OR gates
<li>Four noninverting buffers
<li>Two XOR gates
<li>Four D flip-flops
<li>Two 2-input/1-output multiplexers
<li>Two 1-input/2-output demultiplexers
<li>Four 32-bit counters
<li>Four 32-bit preset counters
<li>Four 32-bit divide-by-N circuits
<li>Four 32-bit up/down counters
<li>Four gate&delay generators
<li>Two quadrature decoders
<li>8 field-input bits
<li>8 field-output bits
<li>One 10MHz clock signal
<li>One 40MHz clock signal
</ul>

<P>In addition to the above listed components, softGlueZynq includes the ability to handle
analog values in much the same way as it handled digital values.  This is accomplished by
encoding analog values as bit streams that can be put on the softGlueZync signal bus.  This
capability is currently rudimentary: only proof-of-principle components have been written.


<hr>
<a name="Installation and deployment"></a>
<h2><center>Installation and deployment</center></h2>

	The simplest way to deploy softGlueZynq is to download and build the module iocZed,
	which builds much of synApps and softGlueZynq and runs it on the Zynq's ARM processor.
	

	<h3>How to get the software</h3>
	softGlueZynq and iocZed are on on GitHub
	(<a href="https://github.com/epics-modules/softGlueZynq">softGlueZynq</a>)
	(<a href="https://github.com/epics-modules/iocZed">iocZed</a>)

	<h3>Building softGlueZynq</h3>

	<ul>

	<li>Edit <code>softGlueZynq/configure/RELEASE</code>, to specify the paths to EPICS_BASE,
	and ASYN.

	<li>Edit <code>iocZed/configure/RELEASE</code>, to specify the paths to EPICS_BASE,
	ASYN, and SOFTGLUEZYNQ.

	<li>Run <code>make</code> in the top-level directories of softGlueZynq and iocZed, using the
	same <code>make</code> executable used to build EPICS base.

	<blockquote>The softGlueZynq build will issue a warning that it can't expand all macros
	in substitution files.  This is not an error; unexpanded macros are intended
	to be defined at boot time.  (Note that version 1-4 of <code>msi</code>
	returns an error, which causes the softGlueZynq build to fail, after writing a
	database file that contains unexpanded macros.) </blockquote>

	</ul>

	<h3>Deploying softGlueZynq to an IOC</h3>
	

	<h3>Configuring softGlueZynq (editing softGlueZynq.iocsh)</h3>

<h4>User Callable Functions:</h4>
<ul>

<li>
<pre>
initZynqSingleRegisterPort(char *portName, int AXI_BaseAddress)
</pre>

<P>Initialize softGlueZynq signal-name support.

<P>Example:

<pre>
initZynqSingleRegisterPort("AXI0", 0x43C00000)
</pre>

</ul>

<hr>
<a name="User's Manual"></a>
<h2><center>User's Manual</center></h2>

<P>Most of the essential user-interface information &mdash; how to connect signals, what the display
elements mean, etc. &mdash; is contained in the descriptions of the "User Menu" and "AND" sections
below.  The remaining sections are mostly for completeness, though some circuit elements do require
further explanation, and the counter sections introduce new display elements for registers
containing decimal numbers.

<P>We're going to have a little trouble with the meanings of "input" and "output", because they
imply a viewpoint, and because we're going to be taking three different viewpoints: those of EPICS
records, circuit elements, and field-wiring connectors.  Usually, in EPICS, we think of an output as
something to which an EPICS record can write, but that definition would be awkward here, because it
would eventually require us, for example, to refer to the output of an AND gate as an "input".  You
just can't discuss digital circuitry intelligibly from that viewpoint.

<P>Therefore, in this documentation, "input" and "output" will normally be from the viewpoint of one
of the circuit elements we'll be wiring.  Field I/O will be an exception, because it's most
conveniently discussed from the viewpoint of the field-wiring connector.


	<h3>MEDM user interface</h3>

<ul>

<hr>
<li><P>User Menu
<P><img src="Menu.gif" name="User Menu">

<P><code>softGlueZynqMenu.adl</code> is the top softGlueZynq display, which serves mostly to call up other
displays.  The menu labelled <code>READ PERIOD</code> specifies the period at which the values of
all signals are sampled for display to the user.


<blockquote>Most softGlueZynq displays are not interrupt driven.  (That would be a disaster, because
inevitably some signals will change state at high frequency.)  So, the states of inputs and outputs
must be sampled periodically, for display to the user.

<P>We've found that it's confusing for users if the poll period is greater than
around 1 second.  We've also found that polling everything at .1 second uses only a few
percent of an MVME2700 CPU.</blockquote>

<hr>
<li><P>AND
<P><img src="AND.gif" name="AND">

<P> On the left of the AND gate are the inputs, each comprised of a blue "= button", a yellow
text-entry field, a number, and what's intended to look like a red LED.  On the right are
essentially the same things in reverse order, but an output's text-entry field is a different
color.  The text-entry fields are used to connect signals together, and the color difference is
intended to remind you of the only rule governing signal connections: if you connect two or more
outputs together, those outputs won't work.

<blockquote>softGlueZynq outputs are engineered to ensure that you can't break anything by connecting
outputs together, but the circuit won't be useful until you fix the error, because the states of
outputs connected together are undefined.  Currently, softGlueZynq doesn't signal this error by
putting offenders into an alarm state.</blockquote>

<P>The yellow text-entry box controls an input.  You have three options:
<ol>

<b><li>Leave empty.</b><br>

Inputs with empty text-entry boxes default to logic value 1.<P>

<b><li>Enter a string that begins with a number.</b><br>

This directly writes a logic value (optionally, a pulse) to the input.

<P>softGlueZynq will parse everything that looks numberish, and convert to a floating point value.  This
sets the input to a logic value: 0 if the nearest integer to the converted value is zero, 1 if it's
not.

<blockquote>Allowing floats, and extra characters after the number makes it easier to drive softGlueZynq
inputs with calcout records, replies from serial devices, etc.</blockquote>

<P>The strings "0!" and "1!" (possibly followed by other ignored characters) direct softGlueZynq to
write a pair of logic values: "0!" writes "0" followed immediately by "1"; "1!" writes "1" followed
immediately by "0".  The time interval between writes is system dependent, and not at all
guaranteed, but it should be much smaller than the interval you could achieve from separate writes. 
On an MVME2700, I measure around 6 &mu;s.


<b><li>Enter a string that begins with something other than a number.</b><br>

This <em>names</em> the signal, and connects it to all other signals with the same name (or with the
same name followed by '<code>*</code>', as described below).  Case is significant in comparing
signal names.

<blockquote>Note that a "signal", as the word is used in this documentation, is a named connection
between softGlueZynq circuit elements.  It might be more intuitive to think of a "signal" as a wire,
to avoid confusing it with, say, field I/O.</blockquote>

<blockquote>Note, if you're using more than one IP-EP20x module, that you can't connect signals implemented in
different IP-EP20x modules using their text-entry boxes. To accomplish this, you must connect the signals to
field I/O and make a physical connection.</blockquote>

</ol>

<P>If you want to use the inverted value of a signal for input to some component, append
'<code>*</code>' to the signal name.  This doesn't change the signal that the input is
connected to, but just tells softGlueZynq to run the signal through an inverter before applying it
to the input.  Note that output signal names may not end with '<code>*</code>'.

<P>In MEDM, you can use Drag-And-Drop to connect a named signal to some other
signal.  When you drop, MEDM will put the PV name of the signal you dragged
from. When you press &lt;Enter&gt;, softGlueZynq's device support will write the
signal name of the source PV to the destination PV.

<P>In caQtDM, you can select the text of a signal name, and use Copy/Paste
(^C/^V) to copy the signal name from one text-entry box to another.

</ol>

<P>Whatever option you choose, you can define at most fifteen different signal names. When you try
to define the 16th name, softGlueZynq will erase whatever you wrote, and put the record into the
"INVALID" alarm state.  (But note, for example, that <code>reset</code> and <code>reset*</code> are
not different signal names, because the trailing '<code>*</code>' is not regarded as part of the
name; it merely describes how the signal should be used.)

<P>Text-entry boxes for output signals won't accept names beginning with a number, or ending with
'<code>*</code>'.  (softGlueZynq will simply strip the offending characters, and leave the rest.)

<blockquote>A signal name beginning with a number can only be a direct-write command; it cannot connect
things together, because the leading number would be misinterpreted by input-signal-name parsing as a
direct-write command.  Output-signal names ending with '<code>*</code>' are logically sensible, but are
not permitted; this simplifies the implementation of '<code>*</code>' appended to input-signal names.
</blockquote>

<P>A signal's blue "= button" is used to find all other signals to which the signal is connected.
While a signal's "= button" is pressed, input signals connected to it are bordered in green, and output
signals connected to it are bordered in orange.  If you ever see two or more orange borders at
the same time, you have outputs connected together, and your circuit won't work.

<P>The little red and black filled circles (LED's), and the numbers next to them, display the states
of their signals.  These display elements are updated at the period specified in the
<code>softGlueZynqMenu.adl</code> display.  If you want the EPICS PV name corresponding to a signal's
logic value, this is the PV name to use.

<P>For completeness, here's the truth table for an AND gate:
<P><table border>
<tr><th>input1<th>input2<th><th>output
<tr><td>0<td>x<td><td>0
<tr><td>x<td>0<td><td>0
<tr><td>1<td>1<td><td>1
</table>

<blockquote>'x' means "either 0 or 1".</blockquote>


<hr>
<li><P>OR
<P><img src="OR.gif" name="OR">

<P><table border>
<tr><th>input1<th>input2<th><th>output
<tr><td>0<td>0<td><td>0
<tr><td>1<td>x<td><td>1
<tr><td>x<td>1<td><td>1
</table>

<hr>
<li><P>BUFFER
<P><img src="BUFFER.gif" name="BUFFER">

<P>The purpose of the buffer element is to permit EPICS to drive several softGlueZynq inputs
by writing to a single PV, without using up a more valuable circuit element, such as the XOR gate below.

<hr>
<li><P>INVERTING BUFFER
<P><img src="INVERTING_BUFFER.gif" name="BUFFER">

<P>There is no inverting buffer - or any other inverting gate - in softGlueZynq.  Signal inversion is
accomplished by appending '*' to the name of a signal used as as input to any logic element, as
demonstrated above for the buffer element.  Note that '*' appended to the name of an output
signal will be removed.

<hr>
<li><P>XOR
<P><img src="XOR.gif" name="XOR">

<P><table border>
<tr><th>input1<th>input2<th><th>output
<tr><td>0<td>0<td><td>0
<tr><td>0<td>1<td><td>1
<tr><td>1<td>0<td><td>1
<tr><td>1<td>1<td><td>0
</table>

<hr>
<li><P>D FlipFlop
<P><img src="DFF.gif" name="D FlipFlop">

<P>The input signal labelled "&gt;" is the "clock" input.  Unlike other signals, clock inputs are
edge sensitive.  All clock inputs in softGlueZynq act on the rising edge of the input signal.

<P>The open circle ("bubble") in the <code>SET</code> and <code>CLEAR</code> inputs' signal paths indicate
that these signals are inverted before being used.  Thus, applying '0' to the <code>CLEAR</code> input causes
the output to be "cleared" (given the value 0).

<P><table border>
<tr><th>SET<th>CLEAR<th>D<th>&gt; (clock)<th><th>Q
<tr><td>0  <td>0    <td>x<td>x   <td><td>undefined
<tr><td>0  <td>1    <td>x<td>x   <td><td>1
<tr><td>1  <td>0    <td>x<td>x   <td><td>0
<tr><td>1  <td>1    <td>any<td>rising edge<td><td>D<sub>BEFORE</sub> (value D had immediately before the rising edge of the clock signal)
</table>

<hr>
<li><P>2-Input Multiplexer
<P><img src="MUX2.gif" name="2-Input Multiplexer">

<P>When <code>SEL==0</code>, <code>OUT=IN0</code>.  When <code>SEL==1</code>, <code>OUT=IN1</code>.

<hr>
<li><P>2-Output Demultiplexer
<P><img src="DEMUX2.gif" name="2-Output Demultiplexer">

<P>When <code>SEL==0</code>, <code>OUT0=IN</code>, and <code>OUT1</code> is undefined (currently
0).  When <code>SEL==1</code>, <code>OUT1=IN</code>, and <code>OUT0</code> is undefined (currently
0).

<hr>
<li><P>Up Counter (32-bit Counter)
<P><img src="UpCntr.gif" name="32-bit Counter">

<P><code>EN==1</code> enables the clock ("&gt;") input, whose rising edge increments the counter value.

<hr>
<li><P>Down Counter (32-bit Preset Counter)
<P><img src="DnCntr.gif" name="16-bit Preset Counter">

<P><code>EN==1</code> enables the clock (">") input, whose rising edge decrements the counter value. 
When <code>LOAD==1</code> the counter is loaded with the value applied to the <code>PRESET</code>
input.  While <code>LOAD==1</code>, the counter does not count down.  While <code>LOAD==0</code> and
<code>EN==1</code>, a rising edge at the clock input decrements the counter.  When the counter value
reaches <code>0</code>, the output <code>Q</code> goes to <code>1</code>; the next rising edge of the
clock returns <code>Q</code> to <code>0</code> (regardless of the states of <code>EN</code> and
<code>LOAD</code>).

<hr>
<li><P>32-bit Divide By N
<P><img src="DivByN.gif" name="Divide By N">

<P><code>EN==1</code> enables the clock (">") input.  Every <code>N</code>'th
rising edge of the clock drives <code>Q</code> to <code>1</code>.  The next
rising edge returns <code>Q</code> to <code>0</code>.    This behavior produces the correct number of rising edges of
the output signal, but it does not guarantee the same number of falling edges.
Therefore, using an inverted copy of the output to clock downstream electronics
will in some cases have inconsistent results.

When <code>N</code>==<code>0</code>, the divide circuitry is bypassed, and the
clock is connected directly to <code>Q</code>.  This is an error; the output
should still be gated by the <code>EN</code> signal.

<P>In softGlueZynq version 2.1 and earlier, the <code>RESET</code> signal doesn't do
anything.  Beginning with softGlueZynq 2.2, the <code>RESET</code> signal loads the
counter with <code>N</code>, so that <code>Q</code> will be driven to
<code>1</code> after <code>N</code> rising edges of the clock. 
<code>RESET</code> does not clear the output <code>Q</code>.  If <code>Q</code>
is <code>1</code>, it will be cleared on the first rising edge of the clock.

<P>

<hr>
<li><P>8 MHz internal clock
<P><img src="8MHz_clock.gif" name="* MHz clock">

<P>An 8 MHz clock derived from the IndustryPack clock is available to softGlueZynq
circuitry as a free standing output.

<hr>
<li><P>Field I/O
<P><img src="Field_IO.gif" name="Field I/O">

<P>This display allows you to connect field I/O signals to each other and to softGlueZynq circuits. 
Note that a "Field Input Bit" looks like and behaves as a softGlueZynq <em>output</em>, because what
you're actually controlling is the output of a buffer driven by the field-input signal.  Similarly,
a "Field Output Bit" looks like and behaves as a softGlueZynq <em>input</em>, because you're actually
controlling the input of a buffer that drives the field-output signal.


<P>The signals in this display are the field inputs or outputs connected to pins 1-16, 17-32, or 33-48
on the IP-EP201's ribbon connector.  The IP-EP201 board supports 48 I/O bits, and permits them to be set
for input or output in groups of 8.

<P>"POLL TIME (MS)" specifies the period at which softGlueZynq reads the I/O ports
for user-display purposes, and for executing the EPICS link associated with 
non-interrupt-enabled I/O bits (see next section).  If an I/O bit has changed
value since the last read, softGlueZynq processes the display record associated with
that bit, so the user will see the new value. If an I/O bit is enabled to
generate interrupts, as described in the next section, the bit will be read
immediately by the interrupt handler, so "POLL TIME" will not matter for that
bit.

<P>Note: If you have a field input connected to an FPGA component, the component
will react to a change in the input value within nanoseconds.  I/O polling is
not involved at all in the logic connection.

<blockquote>You can change the "CONNECTOR&nbsp;#" strings in this display
&mdash; for example, to support a custom signal-breakout module, or to give the
I/O signals application-specific names.  The strings are defined in
<code>softGlueZynqApp/Db/softGlueZynq_FPGAContent.substitutions</code>, as the macro
<code>IOPIN</code> supplied to <code>softGlueZynq_FieldOutput.db</code> and
<code>softGlueZynq_FieldInput.db</code>.  In softGlueZynq 2.3.1, field I/O displays
leave room for longer strings, and there is a an autosave-request file for
these PVs.</blockquote>

<P>During a VME power cycle, and during a VME reset, field outputs are first put into a high
impedance state, then are driven to ground, and finally are driven to values controlled by the user
circuit.  If user-circuit field-outputs are autosaved, they will be restored during the boot;
otherwise, they will default to logic 1 (+5V for TTL).

<P>During a soft reboot (that is, when the vxWorks "reboot" command is given in the ioc console),
field outputs will maintain their values.


<hr>
<li><P>Field I/O Interrupt support
<P><img src="Field_IO_Int.gif" name="Field I/O">

<P>Field-input lines supported by softGlueZynq can generate interrupts on rising edges,
falling edges, both, or neither.  You control this by setting the "INTERRUPT&nbsp;ENABLE"
menu to "Rising", "Falling", "Both", or "None", respectively.  Field output lines can also
generate interrupts: if a bit is designated as an output, the output is connected also to
the input, and to the input's interrupt-generation circuitry.

<P>Interrupts are throttled by softGlueZynq's interrupt handler.  If more than four interrupts have
occurred and not been handled, softGlueZynq will disable interrupts from the offending bit, by setting
the bit's "INTERRUPT&nbsp;ENABLE" menu to "None", and it will direct your attention to the change by
drawing a red box around the menu control.  The box will be erased the next time the menu is written
to.

<blockquote>The number of unhandled interrupts that triggers throttling is adjustable by modifying
drvIP_EP201.c.  You must change the definition of <code>MAX_IRQ</code>, and you must also ensure
that the asyn ring buffers for interrupt driven PV's is larger than <code>MAX_IRQ</code>. (The
default ring buffer size is 10.  Asyn documentation describes how to change it.) </blockquote>

<P>When an interrupt occurs, you can have the signal value written to an EPICS PV, by writing an
EPICS link description into the purple box labelled "ON INTERRUPT, WRITE SIGNAL VALUE VIA THIS
LINK", as shown for input 16 in the above screen shot.

<P><i>For interrupts that may occur too closely spaced in time for softGlueZynq's normal
interrupt-response mechanism to handle reliably, see "Custom Interrupt Handlers", below.</i>

<h4>About EPICS links</h4>

<P>In softGlueZynq displays (and in most other synApps displays), standard EPICS links are displayed as
purple text-entry boxes, in which you describe the link you want to make.  For purposes here, an
EPICS link description is the name of an EPICS PV, followed by one of the following link attributes:

<P><table border>

<tr><td>NPP<td>(default) write value, but do not cause processing.

<tr><td>PP<td>write value and cause processing (if the record containing the PV is "Process
Passive", which means that it's SCAN field has the value "Passive").<br>
You should use this attribute unless you have some reason not to use it.

<tr><td>CA<td>write value and let the record containing the PV decide whether or not to process.

</table>

<blockquote>EPICS will tack on the string " NMS".  This alarm-propagation attribute is not something
end users need to worry about. </blockquote>

<P>For example, to cause a link to write effectively to the top input of the first AND gate
(whose PV name is  <code>zzz:softGlueZynq:AND-1_IN1_Signal</code>, you would write the following
into a purple box:

<pre>zzz:softGlueZynq:AND-1_IN1_Signal PP</pre>

If you only write the PV name, EPICS will supply the link attribute <code>NPP</code>, and your link
will write a value, but the value won't have any effect until the next time the record processes.
(For most PV's in softGlueZynq, the value written by an NPP link won't even be displayed until the
record processes.)

<P><b>Note:</b> if the link writes to a PV in a different IOC, the specified link
attribute will be ignored, and the attribute "CA" will be used instead.

<hr>

<li><P>Everything on one display, with the signal named "clock" highlighted so that all of its connections
are evident.  A signal name gets this treatment when the "= button" next to an input or output is
pressed.  Note that connections to inputs are bordered in green, and connections to outputs are bordered
in orange.

<P><img src="AllBlink.gif" name="All">

<P>This display shows everything in softGlueZynq except interrupt support.

<hr>
<li><P>Convenience
<P><img src="Convenience.gif" name="Convenience">

<P>This display controls two pulse generators implemented in EPICS, with links allowing them to
write to a softGlueZynq input (that is, to a yellow box), and, similarly, two clock generators
implemented in EPICS.  The display also has MEDM related-display callups for two busy records,

<blockquote>The use of EPICS links (the purple boxes in the above display) is described above in
the section "About EPICS links", in the documentation of "Field I/O Interrupt support".</blockquote>

<hr>
<li><P>BusyRecord
<P><img src="BusyRecord.gif" name="Busy Record">

<P>This display controls the value, output link, and forward link of a busy record.  In the
anticipated use with softGlueZynq, one would have some EPICS record outside of softGlueZynq set the busy
record to "Busy" (using a PP link), and arrange for a softGlueZynq interrupt bit (see "Field I/O
Interrupt support", above) to use its EPICS-output link to clear the busy record to "Done" (using a
CA link).

<blockquote>The use of EPICS links (the purple boxes in the above display) is described above in
the section "About EPICS links", in the documentation of "Field I/O Interrupt support".</blockquote>

<blockquote> It's important to <b>set</b> a busy record to "Busy" using a PP link, because the
purpose of a busy record is to represent some external processing as EPICS processing.  This allows
EPICS' execution tracing to signal the completion of the processing.  EPICS only traces processing
started or propagated with a PP link.

<P>It's important to <b>clear</b> a busy record to "Done" with a CA link, because an EPICS PP link
will decline to process any record that is already processing. The busy record is written so that a
CA put will succeed in clearing it and causing its processing to appear done to EPICS.</blockquote>

</ul>
<hr>

<a name="Additional FPGA components"></a>
<h2><center>Additional FPGA components</center></h2>

The following components are not in the standard softGlueZynq package, but in
add-on packages typically made to solve specific problems.

<ul>

<li><P>32-bit Up/Down Counter
<P><img src="UpDnCntr.gif" name="Up/Down Counter">

<P><code>EN==1</code> enables the clock (">") input.  <code>CLEAR==1</code> sets
the current count and the output value <code>Q</code> to zero.  When
<code>UP/DOWN==1</code> the counter counts up.  <code>LOAD</code> sets the
current count to <code>PRESET</code>

<P>
<hr>

<li><P>Quadrature Decoder
<P><img src="QuadDec.gif" name="Quadrature Decoder">

<P>This circuit converts a pair of digital quadrature signals <code>A, B</code>
(for example, signals from an encoder) into a pair of <code>STEP, DIR</code>
signals.  <code>A</code> and <code>B</code> are samples on rising edges of the
<code>CLOCK</code> signal.  If either have changed since the last rising edge,
the travel direction implied by the change is output to <code>DIR</code>, and a
pulse is output to <code>STEP</code>.  The pulse width is equal to the period of
the <code>CLOCK</code> signal, and the input frequency may not be greater than
half the clock frequency.

<P>
<hr>

<li><P>Shift Register
<P><img src="ShiftReg.gif" name="Shift Register">

<P>This circuit converts from parallel to serial, or from serial to parallel.

<P>For parallel-to-serial conversion, a number is written into the
<code>LOADVAL</code> register, and loaded by a positive-going pulse to the
<code>LOAD</code> input.  On each rising edge of the clock input
<code>&gt;</code>, the loaded value is shifted toward the most significant bit,
and the most significant bit is output to the <ocde>Q</code> output.

<P>For serial-to-parallel conversion, the input <code>D</code> is sampled on the
rising edge of the clock input, and that value is shifted into the least
significant bit of the register.

<P>

<li><P>Four-output demultiplexer
<P><img src="softGlueZynq4DEMUX4.gif" name="Four-output demultiplexer">

<P> When SEL0==0 and SEL1==0, OUT0=IN, and other OUTs are undefined (currently 0).<br>
When SEL0==1 and SEL1==0, OUT1=IN, and other OUTs are undefined (currently 0).<br>
When SEL0==0 and SEL1==1, OUT2=IN, and other OUTs are undefined (currently 0).<br>
When SEL0==1 and SEL1==1, OUT3=IN, and other OUTs are undefined (currently 0).<br>

<P> There are two copies of this add-on component:
<ol>

<li>softGlueZynq_2_2_demux4.hex - the basic component, with all inputs and outputs
routed to signal names, as usual for softGlueZynq.

<li>softGlueZynq_2_2_demux4_HW.hex - the same component, but with multiplexer
outputs routed to signal names, as usual, and also hardwired to the last 16
field I/O pins. Thus, DEMUX4-1_OUT0 is connected to pin 33, DEMUX4-1_OUT1 is
connected to pin 34, ..., and DEMUX4-4_OUT3 is connected to pin 48.

</ol>

<li><P>Encoder Time Average circuit
<P><img src="encoderTimeAverage.gif" name="Encoder Time Average circuit">

<P>This circuit is for general encoder support, and also for generating a time
averaged value of an encoder signal.  Up/Down counters 1-4 are copies of the
32-bit Up/Down counter described above.  Up/Down counter 5 is also a 32-bit
Up/Down counter, but it has no "Q" output.  Instead, it has "Q8" and "C8"
outputs.  Q8 is true whenever the 8 least significant bits are all zero.  C8 is
a ripple carry bit, which allows the eight lsbits of this counter to be combined
with any 32-bit counter to make a 40-bit counter. 

<P>MagCmp-1 is a 32-bit magnitude comparator, which produces the signals "A>B"
and "A!=B" on the rising edge of the clock "SAMPLE".  The component also
produces the signals "BCLOCK" and "BDIR" with the following circuitry, which
uses the "Q8" signal from Up/Down counter 5:

<P><img src="softGlueZynq_MagCmp_help.gif" name="softGlueZynq_MagCmp_help.adl">

</ul>

<hr>

<a name="Saving and restoring circuits"></a>
<h2><center>Saving and restoring circuits</center></h2>
	
	softGlueZynq circuits can be saved and restored using <a
	href="http://www.aps.anl.gov/bcda/synApps/autosave/autosave.html">autosave</a>,
	autosave's <i>configMenu</i> facility, <a
	href="http://www.aps.anl.gov/epics/extensions/burt/index.php">BURT</a>, or
	any channel access client that can read and write PV's.  configMenu is
	particularly handy, because it's driven by EPICS PVs, and because it saves a
	time-stamped backup copy of every file it overwrites.

	<P>Whichever method you use, you may need to clear softGlueZynq signal names
	before loading a circuit, because loading over an existing circuit could
	temporarily exceed the available number of signal names.  (Alternatively,
	you could simply load twice, and be confident that the second load will
	succeed.)

	<h4>Saving and restoring circuits with autosave's configMenu facility</h4>

	<P><img src="configMenu.gif" name="configMenu">

	<P>If you have autosave R5-1 or higher, you can use configMenu to save and
	restore circuits.  Here are the steps needed to implement a menu of softGlueZynq
	circuits, and to give the user a GUI display for saving and restoring them. 
	(In the following, <font color="blue">SG</font> is the name of this instance
	of configMenu.  The files it loads and saves will be named "<font
	color="blue">SG</font>_&lt;<i>config Name</i>&gt;.cfg".  For examples, the
	configMenu instance pictured above has files named "<font
	color="blue">SG</font>_clear.cfg", "<font
	color="blue">SG</font>_encoderTest.cfg", etc..)

	<blockquote> <ol> <li>In the IOC's startup directory, create an autosave
	request file, which I'll call "<font color="blue">SG</font>Menu.req", with
	the following content:

	<P><code>
	file configMenu.req P=$(P),CONFIG=$(CONFIG)<br>
	file softGlueZynq_settings.req  P=$(P),H=$(H)
	</code>

	<P><li>Uncomment the following line in the IOC's copy of
	<code>softGlueZynq.cmd</code>:

	<P><code>dbLoadRecords("$(AUTOSAVE)/asApp/Db/configMenu.db","P=zzz:,CONFIG=<font color="blue">SG</font>")</code>

	<li>Add the following line to <code>st.cmd</code>:

	<P><code>create_manual_set("<font color="blue">SG</font>Menu.req","P=zzz:,CONFIG=<font color="blue">SG</font>")</code>

	<li>Add an MEDM related-display entry to bring up the configMenu.adl display.

	<P><code>
	label="SGMenu"<br>
	name="configMenu.adl"<br>
	args="P=zzz:,CONFIG=<font color="blue">SG</font>"
	</code>

	</ol>
	</blockquote>

	<P>softGlueZynq includes configMenu files (*.cfg) for standard example circuits
	in the iocBoot/iocsoftGlueZynq directory.  In actual use, these .cfg files would
	be placed in your application's iocBoot/ioczzz/autosave directory.  For more
	information on configMenu, see the autosave documentation.

	<h4>Saving and restoring circuits with BURT</h4>
	
	The BURT request file <code>softGlueZynqApp/op/burt/softGlueZynq.snap</code> can be
	used to save all softGlueZynq user modifiable PV's.  For example, the following
	command saves the state of softGlueZynq to the file <code>myCircuit.snap</code>.

	<pre>burtrb -f softGlueZynq.req -DPREFIX=zzz:softGlueZynq -o myCircuit.snap</pre>

	<blockquote>
	<dl>
	<dt> "<code>-f softGlueZynq.req</code>"
	<dd>specifies that the request file <code>softGlueZynq.req</code> should be
	used to specify the EPICS PVs whose values are to be saved.   This file
	contains lines like this: "<code>PREFIX:AND-1_IN1_Signal</code>", where
	"<code>PREFIX</code>" is to be replaced by text specific to your ioc.
	<dt>"<code>-DPREFIX=zzz:softGlueZynq</code>"
	<dd>specifies that <code>PREFIX</code>
	is to be replaced by <code>zzz:softGlueZynq</code>.
	<dt>"<code>-o myCircuit.snap</code>"
	<dd>specifies that the saved PV names and values are to be written to the
	snapshot file "<code>myCircuit.snap</code>".
	</dl>
	No doubt your PREFIX will be different from mine, but it should
	be <code>$(P)$(H)</code> from your copy of <code>softGlueZynq.cmd</code>,
	minus the trailing ':' from $(H).  BURT needs the ':' to separate "PREFIX"
	from the rest of the PV names it parses.  If you defined H without a
	trailing ':', you'll need to make some adjustment to satisfy BURT.
	</blockquote>

	<P>The following commands restore the circuit:
	
	<pre>burtwb -f clearAll.snap</pre>
	<pre>burtwb -f myCircuit.snap</pre>

	<P>The first command is often needed because there is a limit to the number
	of signal names that softGlueZynq will accept.  If you neglect to clear all
	signals before restoring a circuit, the allowed number of signal names might
	be exceeded during the restore, if new signal names are defined before old
	signal names are deleted.  (Alternatively, you could simply run the second
	command twice.)

	<P>To restore example circuits included in the softGlueZynq module, or to
	restore a snapshot file emailed to you by some other softGlueZynq user, you will
	need to edit the snapshot file to change PV names such as
	"<code><b>zzz</b>:softGlueZynq:AND-1_IN2_Signal</code>" to PV names in your ioc, which
	might look like  "<code><b>1ida</b>:softGlueZynq:AND-1_IN2_Signal</code>".
	

<hr>
<a name="Example circuits"></a>
<h2><center>Example circuits</center></h2>

<P>The following circuits have been tested and saved in BURT snapshot files, and
as configMenu .cfg files,  as described above (see <i>Saving and Restoring
Circuits</i>).  The snapshot files can be found in
<code>softGlueZynqApp/op/burt</code>; the .cfg files are in iocBoot/iocsoftGlueZynq.

		<ol>
		<li><h4>Motor-pulse gate </h4>

		Positive-going pulses can be gated with an AND gate, by applying the signal to one input of the AND gate,
		and setting the other input to 0(1) to deny(allow) passage through the gate.

		<P>Negative-going pulses can be gated with an OR gate, by applying the signal to one input
		of the OR gate, and setting the other input to 0(1) to allow(deny) passage through the
		gate.

		<li><h4>Gated scaler</h4> <P><i>Files:
			<code>softGlueZynqApp/op/burt/gatedScaler.snap or 
			iocBoot/iocsoftGlueZynq/gatedScaler.cfg</code></i>

		<P>This circuit implements four counter channels, a time base to control
		counting time, an overall gate, and additional circuitry to control
		starting,  stopping, and processing of the count-value records.  Note
		that the scaler is controlled by a busy record from the softGlueZynq
		convenience database, so that client software can discover when counting
		is finished in the standard EPICS way.  See
		<code>softGlueZynqApp/op/burt/gatedScaler.txt</code> for more details.


		<P><img src="gatedScaler.gif" name="gatedScaler">

		<li><h4>Four independent start-time/stop-time pulses</h4>
		<P><i>File: <code>softGlueZynqApp/op/burt/fourPulses.snap or 
		iocBoot/iocsoftGlueZynq/fourPulses.cfg</code></i>

		<P>This circuit produces four separate pulse signals, which start at
		specified start-delay times after (the falling edge of) an initial start
		pulse, and which last for specified pulse-length times.  It uses four
		DnCntr's to implement the start-delay times, and four DivByN's to
		implement the pulse-length times.  Times are specified as multiples of
		the (125 ns) clock period (<code>PRESET</code> for the DnCntr's;
		<code>N</code> for the DivByN's), and these numbers must be greater than
		or equal to 1.  The pulse sequence starts on the falling edge of the
		signal <code>BUF-1</code>, written by a periodically scanned EPICS
		record (one of the softGlueZynq convenience clocks).  One spare signal name
		is available, however, so the pulse sequence could also be started by an
		external signal.

		<P><img src="fourPulses.gif" name="fourPulses">

		<li><h4>Motor-pulse accel/decel gate</h4>
		
		<P><i>Files: <code>softGlueZynqApp/op/burt/accelDecelGate.snap or
		iocBoot/iocsoftGlueZynq/accelDecelGate.cfg</code></i>  <br>
	
		(Non-softGlueZynq support in
		<code>softGlueZynqApp/op/burt/accelDecelGate_transform.sav</code>.)

		<P>If you know the number of steps a stepper motor will move during its acceleration time, you
		can easily arrange to deliver motor pulses to some external circuit only while the motor is
		moving at constant speed.  For a stepper motor controlled by the motor record, the number of
		acceleration/deceleration steps, <code>N<sub>a</sub></code>, can be calculated with the following
		formula:

		<ul>
		<p><code>N<sub>a</sub> = ((VBAS+VELO)/2)*ACCL/MRES</code>
		</ul>

		<P>where, <code>VBAS</code>, <code>VELO</code>, <code>ACCL</code>, and <code>MRES</code> are
		motorRecord fields.
		
		<P>The number of constant-speed steps, <code>N<sub>c</sub></code>, is then

		<ul>
		<P><code>N<sub>c</sub> = ((VAL<sub>end</sub> - VAL<sub>start</sub>)/MRES) -
		2*N<sub>a</sub></code>
		</ul>

		<P>where <code>VAL<sub>end</sub></code> and <code>VAL<sub>start</sub></code> are the final
		and initial values of the motorRecord <code>VAL</code> field.

		<P>The following circuit accepts negative-going motor pulses at input signal 1, gates out
		the first 11 (the value of <code>DnCntr-1_PRESET</code>), and from then on sends motor
		pulses to output pin 17 until a total of 31 (the value of <code>DnCntr-2_PRESET</code>) have
		been sent.  The circuit is reset by writing "1!" (positive-going pulse) to the input of BUF-1.

		<P>The circuit includes some diagnostics, and a mechanism for testing:
			<ul>

			<li><code>UpCntr-1</code> counts all motor pulses; <code>UpCntr-2</code> counts gated
			motor pulses.  Both counters are reset by the same signal that resets the gate circuit.

			<li>A manual reset is implemented using BUF-1.  Writing "1!" to the input of BUF-1,
			as shown, causes a short positive-going pulse to be applied to it, and thus to its output,
			the signal named "reset".

		<P><img src="accelDecelGate.gif" name="accelDecelGate">

		<P>Down counter <code>DnCntr-1</code>, and flipflop <code>DFF-1</code>, together produce a gate
		signal that is 0 after a reset, and that goes to 1 after <code>DnCntr-1_PRESET</code> motor
		pulses.  Down counter <code>DnCntr-2</code>, and flipflop <code>DFF-2</code>, together produce a
		gate signal that is 1 after a reset, and that goes to 0 after <code>DnCntr-2_PRESET</code> motor
		pulses.  We load the number of acceleration steps into <code>DnCntr-1_PRESET</code>, and the
		number of acceleration steps plus constant-speed steps into <code>DnCntr-2_PRESET</code>.

		<P><code>AND-1</code> combines the gate signals produced above into a signal that is 1 while
		the motor is moving at constant speed.

		<P><code>AND-2</code> gates the negative-going motor pulses, using what
		was described in the "Motor-pulse gate" example as a
		positive-going-pulse gate, by inverting the "motor" signal before
		applying it to the gate.

		<P>Note that the down counters are clocked by (rising edges of) "motor", to produce the
		signal used to gate "motor<code>*</code>".  This choice avoids a race condition between simultaneous
		rising edges of "gateOut" and "motor".  (This circuit gates negative-going motor pulses, so
		another way to make the point is to say that the trailing edge of a motor pulse is used to
		produce a gate that will be ready in plenty of time for the leading edge of the next motor
		pulse.)

		<P>Calculations for the circuit are shown in the following screen capture of a transform
		record.

		<P><img src="accelDecelGateCalc.gif" name="accelDecelGateCalc">
		</ol>

<P>For more softGlueZynq-circuit examples, see
<a
href="https://subversion.xray.aps.anl.gov/admin_bcdaext/softGlueZynq_examples">https://subversion.xray.aps.anl.gov/admin_bcdaext/softGlueZynq_examples</a>
Currently, the following circuits are documented:
<ul>
<li>Programmable pulse train
<li>Gated scaler
<li>Pulse burst
<li>Delay generator
<li>Motor accel/decel pulse gate
<li>Debouncer
</ul>


<hr>
<a name="Field wiring"></a>
<h2><center>Field wiring</center></h2>


<hr>
<a name="Implementation"></a>
<h2><center>Implementation</center></h2>

	<h3>FPGA-content files</h3>

	softGlueZynq contains FPGA-content files, only one of which can be loaded at a
time.

<P><dl>
<dt>softGlueZynq_X_X.bin
<dd>This file contains all standard softGlueZynq components.

</dl>

	<h3>Database files</h3>

<dl>

<dt>softGlueZynq_FPGAContent.substitutions

<dd>This substitutions file is run through <code>msi</code> at build time to
produce the database file <code>softGlueZynq_FPGAContent.db</code>.  The database
file loads records matching most of the FPGA content that is loaded at cold-boot
time from <code>softGlueZynq_2_2.hex</code>.<P>


<dt>softGlueZynq_Input.db<br>
softGlueZynq_Output.db

<dd>These databases each support a single softGlueZynq circuit-element I/O bit.<P>

<dt>softGlueZynq_FieldInput.db<br>
softGlueZynq_FieldOutput.db

<dd>These databases each support a single field I/O bit.<P>

<dt> softGlueZynq_InRegister.db

<dd>This database supports reads from a 16-bit register.  (Currently, no
softGlueZynq circuit element uses this database.)<P>

<dt>softGlueZynq_InRegister32.db

<dd>This database supports reads from a 32-bit register, implemented in the FPGA as two 16-bit
registers.<P>

<dt>softGlueZynq_IntBit.db

<dd>This database supports a single input bit, with an interrupt-driven bi record to read the bit
value, and a forward linked bo record to write that value to some user specified EPICS PV.<P>

<dt>softGlueZynq_IntEdge.db

<dd>This database controls the interrupt-enable mask for a single input bit.<P>

<dt>softGlueZynq_Register.db

<dd>This database supports writes to a 16-bit register.  (Currently, no
softGlueZynq circuit element uses this database.)<P>

<dt>softGlueZynq_Register32.db

<dd>This database supports writes to a 32-bit register, such as the "N" value for a divide-by-N
circuit element.<P>

<dt>softGlueZynq_SignalShow.db

<dd>This database implements part of softGlueZynq's mechanism for showing users which signals are
connected together.  When a user presses a signal's "= button", the signal's name is written to a PV
in this database, against which PV all softGlueZynq signals compare their own signal names, to determine
whether or not to display their "connected" boxes.<P>

<dt>softGlueZynq_convenience.db

<dd>This database contains two busy records by which softGlueZynq can signal completion to EPICS, two
software pulse generators, and two software clock generators.<P>

<dt>softGlueZynq_FPGAContentDev.substitutions<br>
softGlueZynq_FPGAIntDev.substitutions

<dd>These files are not used in a standard deployment of softGlueZynq, but are provided for developers
and deployers of custom FPGA-content.  They are essentially the same as
softGlueZynq_FPGAContent.substitutions, and softGlueZynq_FPGAInt.substitutions, but are intended to be used
directly in dbLoadTemplate() commands, rather than run through <code>msi</code> to produce partially
resolved databases loaded by dbLoadRecords().<P>

</dl>



	<h3>Autosave-request files</h3>

<dl>
<dt>softGlueZynq_FPGAContent_settings.req<br>
softGlueZynq_FPGAContent_octupole_settings.req<br>
softGlueZynq_FPGAContent_Encoder_settings.req<br>
softGlueZynq_FPGAContent_s1ID_Vgate_settings.req<br>
softGlueZynq_FPGAInt_settings.req<br>
softGlueZynq_SignalShow_settings.req<br>
softGlueZynq_convenience_settings.req<br>

<dd>These autosave request files correspond with similarly named database or
substitutions files, and take the same macro definitions.<P>

<dt>softGlueZynq_settings.req

<dd>This autosave-request file <i>includes</i> softGlueZynq_SignalShow_settings.req,
softGlueZynq_FPGAContent_settings.req, softGlueZynq_FPGAInt_settings.req, and
softGlueZynq_convenience_settings.req.  For standard softGlueZynq, this is the only
autosave-request file an IOC needs.<P>

</dl>

	<h3>Display files (MEDM, CSS-BOY, and caQtDM)</h3>

	There are too many display files to describe individually, and many are
	similar, so I'll just describe classes of display files, and the overall
	implementation strategy.  Displays whose names begin with "softGlueZynq_"
	support individual circuit elements.  Displays whose names are of the form
	"softGlueZynqXxx" (no underscore after "softGlueZynq") support collections of
	circuit elements, either by implementing menus for calling up other
	displays, or by including several "softGlueZynq_" displays.  ("Include", in this
	context, means specified as a "Composite File", with macro arguments, in the
	definition of an MEDM grouped item, or specified as a "linkgroup" in
	CSS-BOY.)

	<P>In the rest of this display-file documentation, I'll give MEDM examples.
	For CSS-BOY examples, just substitute ".opi" for ".adl".  For caQtDM,
	substitute ".ui".

	<P>The display of a softGlueZynq circuit element is built in layers, from
	instances of softGlueZynq_Input.adl and softGlueZynq_Output.adl, which are
	<i>included</i> in softGlueZynq_&lt;element name&gt;_bare.adl, which in turn is
	included in one of the user displays (for example, softGlueZynqAll.adl,
	softGlueZynq_AND.adl, etc.).

	<P><dl>
	<dt>softGlueZynqMenu.adl<br>
	softGlueZynqTop.adl

	<dd><code>softGlueZynqMenu.adl</code> contains related-display menus for everything in softGlueZynq.
	<code>softGlueZynqTop.adl</code> is an example of how <code>softGlueZynqMenu.adl</code> can be called up.

	<dt>softGlueZynq_Input.adl<br>
	softGlueZynq_Output.adl
	
	<dd>These displays support a <i>single 16-bit register component</i> (see "Driver", below) in the
	FPGA, and most softGlueZynq circuit-element displays include several instances of these displays.  For
	example, softGlueZynq_AND_bare.adl includes two instances of softGlueZynq_Input.adl, and one instance of
	softGlueZynq_Output.adl.

	<dt>softGlueZynq_*.adl<br>
	softGlueZynq_*_bare.adl, where * is one of AND, BUFFER, DEMUX2, DFF, DivByN, DnCntr, MUX2, MUX4, OR, Shift32, UpCntr, XOR

	<dd>These files each support a single circuit element, such as an AND gate.  The "_bare.adl"
	displays are intended to be included in some other display.

	<dt>softGlueZynq_Field*.adl<br>
	softGlueZynq_Field*_bare.adl, where * is one of FieldInput, FieldOutput, IntBit.    The "_bare.adl"
	displays are intended to be included in some other display.

	<dd>These files support a single field-I/O bit, or the interrupt control and dispatch records
	associated with a field-I/O bit.

	</dl>

	<h3>Driver</h3>
	
	<P>softGlueZynq's driver implements four asyn ports to connect EPICS records with registers
	implemented in the IP-EP20x module's FPGA.  Three ports connect with "fieldIO_registerSet"
	components, which provide comprehensive control over digital I/O bits implemented in the module,
	including data direction (i.e., read or write), interrupt enable, and status.  The fourth asyn
	port connects with "single 16-bit register" components, with which all softGlueZynq signal
	connections are implemented.

		<P>The following is copied from drvIP-EP201.c:

		<pre>
    This driver cooperates with specific FPGA firmware loaded into the Acromag
    IP-EP201 (and probably other IP-EP200-series modules).  The loaded FPGA
    firmware includes Eric Norum's IndustryPack Bridge, which is an interface
    between the IndustryPack bus and the Altera FPGA's Avalon bus.  The
    IndustryPack Bridge does not define anything we can write to in the FPGA. 
    It's job is to support additional firmware loaded into the FPGA.  The
    additional firmware defines registers that we can read and write, and it can
    take one of the two forms (sopc components) supported by this driver:

        1) fieldIO_registerSet component

           A set of seven 16-bit registers defined by 'fieldIO_registerSet'
           below.  This register set provides bit-level I/O direction and
           interrupt-generation support, and is intended primarily to
           implement field I/O registers.

        2) single 16-bit register component

           a single 16-bit register, which has no interrupt service or bit-level
           I/O direction.  This type of sopc component is just a plain 16-bit
           register, which can be written to or read.  This driver doesn't know
           or care what the register might be connected to inside the FPGA.

    Each fieldIO_registerSet component must be initialized by a separate call to
    initIP_EP201(), because the component's sopc address must be specified at
    init time, so that the interrupt-service routine associated with the
    component can use the sopc address.  Currently, each call to initIP_EP201()
    defines a new asyn port, connects an interrupt-service routine, creates a
    message queue, and launches a thread.

    Single 16-bit register components, on the other hand, need not have their
    sopc addresses known at init time, because they are not associated with an
    interrupt service routine.  As a consequence, many such single-register
    components can be served by a single asyn port.  Users of this port must
    specify the sopc address of the register they want to read or write in
    their asynUser structure. Records do this by including the address in the
    definition of the record's OUT or INP field.  For example, the ADDR macro in
    the following field definition should be set to the register's sopc address:
    field(OUT,"@asynMask($(PORT),$(ADDR),0x2f)")

    The addressing of sopc components requires some explanation.  When a
    component is loaded into the FPGA, it is given an sopc address, which is a
    number in one of two regions of the Avalon address space.  These regions of
    Avalon memory space are mapped by the IndustryPack Bridge to specific ranges
    of the IndustryPack module's IO and MEM spaces.  The IO and MEM spaces, in
    turn, are mapped by the IndustryPack carrier, and by the ipac-module
    software, to corresponding ranges in a VME address space.  The lowest
    address in the IndustryPack module's IO space is mapped to the VME A16
    address given by ipmBaseAddr(carrier, slot, ipac_addrIO), which I'll call
    IOBASE in the following table.  The lowest address in the IndustryPack
    module's MEM space is mapped to the VME A32 address given by
    ipmBaseAddr(carrier, slot, ipac_addrMem), which I'll call MEMBASE in the
    following table.  (The module's MEM space could also have been mapped to the
    VME A24 space.  This code doesn't know or care, because it just gets the VME
    address by making a function call to code provided by the ipac module.)
    
    Note that IOBASE and MEMBASE depend on the IndustryPack carrier and slot
    into which the IP-EP200 module has been placed.

    Avalon_address | IP_space  IP_address  | VME_space   VME_address
    (sopc address) |                       |                 
    ---------------|-----------------------|-----------------------------
    0x000000       | IO        0x000000    | A16         IOBASE+0x000000     
    ...            | IO        ...         | A16         ...             
    0x00007f       | IO        0x00007f    | A16         IOBASE+0x00007f     
                   |                       |                                        
    0x800000       | MEM       0x000000    | A32         MEMBASE+0x000000
    ...            | MEM       ...         | A32         ...
    0xffffff       | MEM       0x7fffff    | A32         MEMBASE+0x7fffff
    
    Thus, if a component is created with the sopc address 0x000010, it can be
    accessed at the IO-space address 0x000010, which is mapped to the VME
    address IOBASE+0x000010.  If a component is created with the sopc address
    0x800003, it can be accessed at MEM-space address 0x000003, which is
    mapped to the VME address MEMBASE+0x000003.

    Note that users of this code are not expected to know anything about this
    address-mapping business.  The only address users ever specify is the sopc
    address, exactly as it was specified to Quartus.

		</pre>

	<h3>Device support</h3> <P>softGlueZynq uses standard asyn device support for everything except
		signal names, which are handled by devAsynsoftGlueZynq.c.  The driver supports asynInt32 and
		asynUInt32Digital interfaces; devAsynsoftGlueZynq.c uses asynUInt32Digital.

		<P>devAsynsoftGlueZynq.c maintains lists of signal names and associates each signal name with
		one of 15 bus lines implemented in the FPGA.  When a new signal name is encountered, it is
		assigned to an unused bus line (or ignored if there are no unused bus lines). The bus line
		number is written to a register, in the FPGA, which controls a multiplexer (for input
		signals) or demultiplexer (for output signals).
		
		<P>If an input signal name ends with '<code>*</code>', a register bit is set that causes the
		output of the multiplexer to be routed through an inverter before being connected to the
		circuit element.  If an input signal is numeric, it is assigned to multiplexer address 0,
		which is driven not by a bus line, but by a register bit set according to the numeric value.
		(If '<code>*</code>' is appended to a numeric signal, it's ignored.)

	<h3>Field I/O</h3>
		<P> Field inputs and outputs are supported by two independent sets of binary input and
		output records:

		<dl>

		<dt>softGlueZynq-supported records

		<dd>These records are part of a database that also includes
		signal-wiring fields (the <code>softGlueZynq_FPGAContent.db</code>
		database); they are connected to hardware via softGlueZynq's asyn port (the
		port initialized by the function
		<code>initIP_EP201SingleRegisterPort()</code>), and no interrupt support
		is provided for them.  They are polled at a rate determined by the
		<code>READ PERIOD</code> menu on the <code>softGlueZynqMenu.adl</code>
		display.

		<dt>non-softGlueZynq-supported records

		<dd>These records are loaded separately from the records described
		above (they are loaded by the <code>softGlueZynq_FPGAInt.db</code> database); they
		are connected to hardware via the asyn port initialized by the function
		<code>initIP_EP201()</code>, and they can be interrupt driven.  They are also
		polled periodically.  The polling period's initial value is specified as an
		argument to <code>initIP_EP201()</code>, and it can be modified by the user
		via the <code>POLL TIME (MS)</code> text entry on
		<code>softGlueZynqFieldIO*.adl</code> displays.
		</dl>

	<h3>FPGA content</h3>

<h4>IndustryPack bus interface</h4>
All communication between EPICS and the FPGA goes through Eric Norum's IP-bus interface,
which is described in <a href="IndustryPackBridge.html">IndustryPackBridge.html</a>.

<h4> Single-register component</h4>

Most of softGlueZynq is implemented with single-register FPGA components connecting to standard
digital circuitry, such as AND gates, counters, etc., through interface circuitry of the
following three types:

<P><dl>

<dt>Input

<dd>An input is essentially a 16-input multiplexer controlled by a register that softGlueZynq
can write to and read from.  Inputs 1-15 of all input multiplexers are connected together to form a
15-line bus, so that all inputs with the same multiplexer address are connected together.

<P>Input 0 of the multiplexer is special: it connects to the "U" bit of the signal's control
register, instead of to a bus line, and is the means by which softGlueZynq implements direct user
control of the signal value.  When the user writes "0" or "1" as a signal name, softGlueZynq sets the
multiplexer address to zero, and sets the "U" bit to 0 or 1.

<P>A second register bit, "N", controls whether or not the multiplexer output is routed through an
inverter before connecting to the payload digital circuit element input; this bit is the means by
which softGlueZynq implements names like "reset*", which connects the input to an inverted copy of the
signal, "reset".  The invert bit could be, but currently is not, used with the "U" bit.

<P><table border>
<tr><td>bit:<td>15<td>14<td>13<td>12<td>11<td>10<td>&nbsp;9<td>&nbsp;8<td>&nbsp;7<td>&nbsp;6<td>&nbsp;5<td>&nbsp;4<td>&nbsp;3<td>&nbsp;2<td>&nbsp;1<td>&nbsp;0
<tr><td>function:<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>N<td>R<td>U<td>A<sub>3</sub><td>A<sub>2</sub><td>A<sub>1</sub><td>A<sub>0</sub>
</table>

<P>where
<P><table border>
<tr><td>N<td>invert-signal bit
<tr><td>R<td>read bit
<tr><td>U<td>user-write bit
<tr><td>A<sub>n</sub><td>bus-line address bit
</table>

<dt>Output

<dd>An output is a signal routed via a demultiplexer to any of 15 bus lines.  No connection is made
to the demultiplexer output selected by the address 0; this address is used to implement unconnected
output signals.

<P><table border>
<tr><td>bit:<td>15<td>14<td>13<td>12<td>11<td>10<td>&nbsp;9<td>&nbsp;8<td>&nbsp;7<td>&nbsp;6<td>&nbsp;5<td>&nbsp;4<td>&nbsp;3<td>&nbsp;2<td>&nbsp;1<td>&nbsp;0
<tr><td>function:<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>&nbsp;&nbsp;<td>R<td>&nbsp;&nbsp;<td>A<sub>3</sub><td>A<sub>2</sub><td>A<sub>1</sub><td>A<sub>0</sub>
</table>
<P>where R and A<sub>n</sub> are as defined above for the input register.

<dt>16-bit register<dd>integer value written by EPICS to a parameter register with a fixed connection
to a specific device instance.  softGlueZynq uses two 16-bit registers to implement the 32-bit
up counter.


</dl>

<h4> Field I/O register set component ("IP_EP20x") </h4>


This SOPC component supports 16 bits of field I/O
<h5> Registers </h5>

<table border>
<tr><th>Address Offset<th>Function<th>Description<th>Read/Write
<tr><td>0<td>Control/Status<td>Field-I/O direction, IRQ status<td>Read/Write
<tr><td>1<td>Field I/O Write Data OR Diff/Dir register<td>Write Field I/O or differential/direction register, depending on the FPGA content and how "DIFF_DIR" is defined in drvIP_EP201.c<td>Read/Write
<tr><td>2<td>Field I/O Read Data<td>Read Field I/O ONLY when dir = 0<td>Read
<tr><td>3<td>Rising IRQ Status Bits<td>Which Bits are causing interrupt from field I/O on transition to 1<td>Read/Write*
<tr><td>4<td>Rising IRQ Interrupt-Enable Bits<td>Which Rising edge bits have IRQ Enabled<td>Read/Write
<tr><td>5<td>Falling IRQ Status Bits<td>Which bits are causing interrupt from field I/O on transition to 0<td>Read/Write*
<tr><td>6<td>Falling IRQ Interrupt-enable bits<td>Which bits have falling IRQ enabled<td>Read/Write
<tr><td colspan=4>* A write to this register clears interrupts for nonzero bits.  For example, after servicing
a rising-edge interrupt from bit 0, the interrupt-service routine writes 0x01 to register 3 before re-enabling interrupts.
</table>

<h5> Control/Status-register bits </h5>
<table border>
<tr><th>Bit<th>Function<th>Value<th>Description
<tr><td>0<td>Field I/O Direction Lower 8-Bits<td>0=Input, 1=Output<td>Sets I/O direction for the lower 8 field-I/O bits (single-ended signals only)
<tr><td>1<td>&nbsp<td>0<td>&nbsp
<tr><td>2<td>&nbsp<td>0<td>&nbsp
<tr><td>3<td>&nbsp<td>0<td>&nbsp
<tr><td>4<td>&nbsp<td>0<td>&nbsp
<tr><td>5<td>Falling Edge IRQ Present<td>1=Present<td>Falling Edge interrupt from bits 0-7 sets bit to 1
<tr><td>6<td>Rising Edge IRQ Present<td>1=Present<td>Rising Edge interrupt from bits 0-7 sets bit to 1
<tr><td>7<td>Lower 8-bits IRQ Present<td>1=Present<td>Interrupt from bits 0-7 sets bit to 1
<tr><td>8<td>Field I/O Direction Upper 8-Bits<td>0=Input, 1=Output<td>Sets I/O direction for the upper 8 field-I/O bits (single-ended signals only)
<tr><td>9<td>&nbsp<td>0<td>&nbsp
<tr><td>10<td>&nbsp<td>0<td>&nbsp
<tr><td>11<td>&nbsp<td>0<td>&nbsp
<tr><td>12<td>&nbsp<td>0<td>&nbsp
<tr><td>13<td>Falling Edge IRQ Present Upper 8-Bits<td>1=Present<td>Falling Edge interrupt from bits 8-15 sets bit to 1
<tr><td>14<td>Rising Edge IRQ Present  Upper 8-Bits<td>1=Present<td>Rising Edge interrupt from bits 8-15 sets bit to 1
<tr><td>15<td>Upper 8-bits IRQ Present<td>1=Present<td>Interrupt from bits 8-15 sets bit to 1
</table>

<h5> Diff/Dir-register bits </h5>
<table border>
<tr><th>Bit<th>Function<th>Value<th>Description
<tr><td>0<td>Field I/O Direction Bit 0<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>1<td>Field I/O Direction Bit 1<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>2<td>Field I/O Direction Bit 2<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>3<td>Field I/O Direction Bit 3<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>4<td>Field I/O Direction Bit 4<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>5<td>Field I/O Direction Bit 5<td>0=Input, 1=Output<td>Sets I/O direction for differential signals only
<tr><td>6<td>Differential<td>1=lower eight bits represent four differential signals<td>See Diff/Dir note below
<tr><td>7<td>Differential<td>1=upper eight bits represent four differential signals<td>See Diff/Dir note below
<tr><td>8<td>&nbsp<td>0<td>&nbsp
<tr><td>9<td>&nbsp<td>0<td>&nbsp
<tr><td>10<td>&nbsp<td>0<td>&nbsp
<tr><td>11<td>&nbsp<td>0<td>&nbsp
<tr><td>12<td>&nbsp<td>0<td>&nbsp
<tr><td>13<td>&nbsp<td>0<td>&nbsp
<tr><td>14<td>&nbsp<td>0<td>&nbsp
<tr><td>15<td>&nbsp<td>0<td>&nbsp
</table>

	<h4>Diff/Dir note</h4>

Field-I/O data direction for IP_EP200-series modules is awkward and unfortunate, and is different for the different module
types.  The module types differ in which I/O bits are single ended and which are differential.  Bit numbering can be a little
confusing in this context, because two single ended signals from one module type use the same pins as a single differential
signal from another module type.  In this documentation, I'll just talk about field I/O connector pins, which are numbered
1-48, and which are the same for all module types.

<P><dl>
<dt>IP_EP201<dd>pins 1-48 are single ended.
<dt>IP_EP202 & IP_EP204<dd>pins 1-48 are differential.  The software acts like it's driving only odd
numbered pins, because the even numbered pins are their differential pairs.
<dt>IP_EP203<dd>pins 1-24 are single ended, pins 25-48 are differential.  For differential pins, the
software acts like it's driving only odd numbered pins, because the even numbered pins are their
differential pairs.
</dl>

<P>For single ended pins, data direction is controlled by the Control/Status register of a "Field I/O register set" component. 
Each component controls 16 I/O pins.  Bit 0 of Control/Status controls the direction of the lower eight I/O pins, bit 8
controls the direction of the upper eight pins.

<P>For differential pins, data direction is controlled by bits 0-5 of the Diff/Dir register of the first (lowest SOPC address)
"Field I/O register set" component.

<P>FPGA content must be told which pins are single ended and which are differential.  Bits 6-7 of the Diff/Dir register of a
"Field I/O register set" component are used for this purpose.  If bit 6 is 1, the lower eight I/O pins are differential.  If
bit 7 is 1, the upper eight I/O pins are differential.  

	<h3>Miscellaneous notes</h3>

The following notes have not been integrated into the documentation yet.
They are included for completeness.

<pre>



------------------------------------------------------------------------------
Deployment considerations

We need to ensure that the software agrees with the FPGA programming.  Software
dependence on FPGA content is of three kinds:

1) Dependence on the register set with which SOPC components are implemented. There are two
   different register sets currently in use: Marty Smith's original register set (called
   'fieldIO_registerSet' in comments within drvIP_EP201.c), and Kurt Goetze's register set (called
   'single 16-bit register' &mdash; a misnomer, because there are several registers in the component, but
   thus far only one register is used.) This dependence is restricted to the driver code,
   drvIP_EP201.c.

2) Dependence on the user circuits attached to 'single 16-bit register' SOPC components.  For
   example, the version 2.0 implementation of softGlueZynq has several AND gates, several OR
   gates, some counters, etc., controlled by 'single 16-bit register' components.

   This dependence is restricted to the database, autosave-request file, and MEDM displays, which
   should have an analog for each 'single 16-bit register' component, and which should know which
   component address corresponds with which user circuit, and with which part of the user circuit.
   For example, the inverting output of AND gate #1 is associated by address with a 'single
   16-bit register' component.

3) Dependence on field I/O direction settings.  In softGlueZynq 2.x, field I/O direction is not
adjustable by the user, but is fixed at boot time.  All databases and MEDM-display files are
compatible with any choice of field I/O direction settings, though MEDM displays don't give
the user any information about which bits are inputs and which are outputs.

Currently, the only strategy in use for ensuring that EPICS support agrees with FPGA content is the
inclusion of FPGA content with softGlueZynq.  Deployers are expected to copy files from
softGlueZynq/iocBoot/iocsoftGlueZynq for initial deployment, and to copy them again for any version
upgrades, or else to take responsibility themselves for agreement between software and firmware.

------------------------------------------------------------------------------
Programming the FPGA via the IP bus.

The IP-EP20x board has to be prepared for this by moving the DIP jumper to
"IP BUS".  (This is the factory default setting.)

The hex file to be loaded is included in the softGlueZynqApp/Db directory.
It was prepared as follows, in Quartus, according to an email from Marty Smith:

1. Under programming type select the Hexadecimal file format for Intel
2. Select your file name
3. Add your .sof file
4. Select the sof file and hit the properties button
5. Select the compression box
6. Make sure that you have selected 1-bit Passive Serial above for the mode
7. Select the options button under programming file type
    make sure that you have a start address of 0x0 and that the count up
    radio button is selected
8. Generate your file
</pre>


<hr>

<h3>Credits</h3>

The essential enabling work underlying softGlueZynq is Eric Norum's <a
href="IndustryPackBridge.html">IndustryPack Bridge</a>.  David Kline engineered
a proof-of-principle implementation, working from another of Eric's
bus-interface solutions, for a non-VME architecture.  Marty Smith wrote a driver
to talk to custom FPGA content interfaced to Eric's IndustryPack Bridge.  Kurt
Goetze and Marty Smith implemented the FPGA content included with softGlueZynq, and
Tim Mooney extended Marty's driver and wrote the EPICS application.

<hr>
<ADDRESS STYLE="text-align: left">Suggestions and Comments to: <br>
<A HREF="mailto:mooney@aps.anl.gov">
Tim Mooney </A>: (mooney@aps.anl.gov) 
</ADDRESS>
</BODY>
</HTML>
